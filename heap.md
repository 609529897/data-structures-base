# heap 堆

- 构建优先队列

- 完全二叉树作为容器（不一定是完全二叉树）

- 最快获得最小/最大值

> 完全二叉树：当一个二叉树深度为 k ，那个除了 k 层别的层都是满的，而 k 层的所有数据都在左边

分类

- 大顶堆：父节点的值比每个子节点大，那么最大值总是存放在最上面
  
- 小顶堆：跟上面👆的相反

堆跟普通树的区分

- **节点的顺序** 在二叉树中左子节点比父节点小，右节点比父节点大，在堆中两个节点都比父节点小或者大

- **内存占用**  普通树 > 堆，因为普通树要为节点对象和左/右子节点指针分配内存，堆只需要一个数组存储到内存，且不需要指针

- **平衡**     二叉搜索树必须是平衡的条件才能达到 O(log n) 的时间复杂度，而堆不需要满足这个条件

- **搜索**     搜索是二叉树比较擅长的范围，堆中比较慢。使用堆的目的是将最大/最小的节点放在最前面，从而快速的进行相关插入、删除操作。
 
构建堆

- 使用数组

- 可以使用公式去标记出父子节点的关系

```javascript
[ 10, 7, 2, 5, 1 ]

// i 是索引值
parent (i) = floor((i - 1)/2) // 父节点
left (i) = 2i + 1             // 左子节点
right (i) = 2i + 2            // 右子节点
```

```javascript
array[parent(i)] >= array[i]
```

堆的高度

```javascript
h = floor(log2(n)) // n 是节点
```

堆操作

时间复杂度 `O(log n)`

- **shiftUp** 如果一个节点比它的父节点 大/小 那么这个节点需要上升

- **shiftDown** 如果一个节点比它的子节点 大/小 那么这个节点需要下沉

---

时间复杂度 `O(log n)`

- **insert(value)** 在堆的尾部添加一个新的元素并用 shiftUp 修复它

- **remove** 移除并返回最大/最小的元素，并把最后一个元素拿到顶部位置，并用 shiftDown 修复它

- **removeAtIndex(index)** 删除任意位置的元素，并与它父子节点进行比较并修复堆

- **replace(indnx, value)** 将一个最大/最小的值赋值给节点，后续需要使用 shiftUp 修复

---

- **search(value)** 搜索，一般是为了 replace() 和 removeAtIndex() 时找到该节点在数组中的 index 的

- **buildHeap(array)** 反复调用 insert 方法最后把一个数组变成堆

- **peek()** 不用返回删除节点返回最大/最小值
