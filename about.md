# 数据结构与算法

## 代码效率优化

### 复杂度：衡量程序运行的效率

> 时间复杂度和空间复杂度: 时间复杂度 => 计算时间，空间复杂度 => 环境资源

- 它与具体的系数无关，O(n) 和 O(2n) 表示的是同样的复杂度

- 复杂度相加的时候，选择高者做为结果，也就是 O(n^2) + O(n) 和 O(n ^ 2) 表示的是同样的复杂度

- O(1) 也是表示一个特殊复杂度，及任务与算例个数 n 无关

**时间复杂度**与代码的结构设计高度相关

**空间复杂度**与代码中的数据结构的选择高度相关

### 数据结构：复杂度降低的核心方法论

> "昂贵"的时间复杂度转换成"廉价"的空间复杂度

降低复杂度的方法的三个步骤：

1. **暴力解法：**在没有任何时间、空间的约束下，完成代码任务的开发
2. **无效操作处理：**将代码中的无效计算、无效存储剔除，降低时间或空间复杂度

（学会并掌握 *递归* 、*二分法*、*排序算法*、*动态规划* 等常用的算法思维）

3. **时空转换：**设计合理数据结构，完成时间复杂度向空间复杂度的转移

（对数据的操作进行细分，全面掌握常见的数据结构的基础知识）

---

## 数据结构基础

### 增删查

- **增**和**删**可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删区别在于原数据的位置是否发生改变
- **查找**可以细分为按照位置条件的查找和按照数据数值特征的查找

> 如果不知道用什么数据结构的时候，就要从数据需要被处理的动作出发

### 线性表

线性链表结构的每个结点，有数据的数值和指向下一个元素的指针构成

据结构组合方式的不同，除了单向链表以外，还有双向链表、循环链表以及双向循环链表等变形

- 链表在**增**、**删** 方面比较容易实现，可以在 O(1) 的时间复杂度内完成
- 对于查找，需要对全部数据进行遍历

**线性表**的价值在于，它对数据的存储方式是按照顺序的存储

当数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适

**链表的翻转**、**快慢指针的方法** ，是必须掌握的内容

**案例**

1. 翻转链表

三指针：1. prev 前元素 2. curr 当前元素 3. next 下一个元素

2. 给定一个奇数个元素的链表，查找出这个链表中间位置的结点的数值

快慢指针

```javascript
while(fase && fase.next && fase.next.next) {
  fase = fast.next.next
  slow = slow.next
}
```

3. 判断链表是否有环

快慢指针：如果有环，快慢指针一定会相遇

### 限制后的线性表 - 栈

**栈**是个限制版的线性表，限制的功能是，**只允许数据从栈顶进出**

顺序栈/链式栈，它们对于数据的新增操作和删除操作的时间复杂度都是 **O(1)**

查找跟线性表一样，只能通过全局遍历的方式进行，需要 **O(n)** 的时间复杂度

**栈具有后进先出的特性**，当面对问题需要高频的新增、删除操作且新增和删除的数据执行顺序具备后来居上的相反关系时，栈就是个不错的选择

例如浏览器的前进和后退，括号匹配等问题

```javascript
function main(args) {
  const strings = "{[()()]}"
  console.log(isLegal(strings))
}

function isLeft() {
  if(c === "{" || c === "(" || c === "[") {
    return 1
  } else {
    return 2
  }
}

function isPair(p, curr) {
  if ((p === "{" && curr === "}") || (p === "[" && curr === "]") || (p === "(" && curr === ")")) {
      return 1
  } else {
    return 0
  }
}

function isLegal(s) {
  const stack = [];
  for(let i = 0; i < s.length; i++) {
    const curr = s.charAt(i)
    if (isLeft(curr) === 1) {
        stack.push(curr)
     } else {
        if(stack.length === 0) {
          return "非法"
        } else {
          const p = stack.pop()
          if(isPair(p, curr) === 0) {
            return "非法"
          }
       }
    }
    if (stack.length === 0) {
      return "合法"
    } else {
      return "非法"
    }
  }
}
```

### 队列

加了限制的线性表

时间复杂度

- 循环队列和链式队列的新增、删除操作都为 O(1) 
- 查找操作，全局遍历 O(n)

空间性能

- **循环队列**必须有一个固定的长度，因此存在存储元素数量和空间的浪费问题
- **链式队列**更为灵活
- 在可以确定队列长度值时，建议使用**循环队列**
- 无法确定队列长度时，应考虑使用**链式队列**

队列具有先进先出的特点

在面对数据处理顺序非常敏感的问题时，**队列**是个不错的技术选型

**案例**

约瑟夫环：从编号为 k 的开始报数，数到 m 的那个人出列，他的下一个人从 1 开始报数，数到 m 的那个人出列，依次完成全部出列为止

```javascript
function main() {
  ring(10, 5)
}

function ring(n, m) {
  const linkedList = [];
  for(let i = 1; i <= n; i++) {
    linkedList.push(i)
  }
  let k = 2;
  let element = 0
  let i = 0
  for (;i < k; i++) {
    element = linkedList.shift();
    linkedList.push(element)
  }
  i = 1
  while (linkedList.length > 0) {
    element = linkedList.pop()
    if (i < n) {
      linkedList.push(element)
      i++
    } else {
      i = 1
      console.log(element)
    }
  }
}
```

### 数组

数组更适合在数量确定

即较少甚至不需要使用新增数据，删除数据操作的场景下使用

**在数据对位置敏感的场景下**

比如需要高频根据索引位置查找数据时，数组就是个很好的选择

### 字符串

逻辑结构和线性表极为相似，区别仅在于**串的数据对象约束为字符集**

字符串的基本操作和线性表有很大差别：

- 在**线性表**的基本操作中，大多以**"单个元素"**作为操作对象
- 在**字符串**的基本操作中，通常以**串的整体**作为操作对象
- 字符串的增删操作和数组很像，复杂度也与之一样，但字符串的查找操作复杂很多

**案例**

1. 从给定的字符串中查找是否有某个子字符串

```javascript
function query() {
  const a = "goodgoogle"
  const b = "google"
  let isFind = 0
  for (let i = 0; i < a.length - b.length + 1; i++) {
    if (a[i] === b[0]) {
      let jc = 0
      for (let j = 0; j < b.length; j++) {
        if (a[i + j] !== b[j]) {
          break
        }
        jc = j
      }
      if (jc === b.length - 1) {
        isFind = 1
      }
    }
  }
  console.log(isFind)
}
```

2. 从两个字符串中查找出共同仅有的一个最长子字符串

```javascript
// O(nm^2)
function query() {
  const a = "123456"
  const b = "13452439"
  let max_str = ""
  let max_len = 0

  for (let i = 0; i < a.length; i++) {
    for (let j = 0; j < b.length; j++) {
      if (a[i] === b[j]) {
        for (let m = i, n = j; m < a.length && n < b.length; m++, n++) {
          if (a[m] !== b[n]) {
            break
          }
          if (max_len < m - i) {
            max_len = m - i
            max_str = a.substring(i, m)
          }
        }
      }
    }
  }
  console.log(max_str)
}
```

### 树和二叉树

树是由结点和边组成的，不存在环的一种数据结构

![二叉树](/Users/ningnarigele/Desktop/al/images/erchashu.png)

**存储二叉树**

- 基于指针的链式存储法
- 基于数组的顺序存储法

如果结点 x 的下标为 i

x 的**左子结点**总是存放2 * i 的位置

x 的**右子结点**总是存放在**2 * i + 1** 的位置

**树的基本操作**

- 数据结构都是"一对一"的关系，即前面的数据只跟下面的一个数据产生联系关系，例如链表、栈、队列等
- **树结构**是**"一对多"**的关系，即前面的父结点，跟下面若干个子结点产生了连接关系

遍历

> 序：父结点的遍历顺序

- 前序遍历
- 中序遍历
- 后序遍历

时间复杂度

- 遍历：`O(n)`
- 删除，添加 `O(1)`
- 但是删除和添加的操作必然需要遍历，所以真正删除和添加时间复杂度是 `O(n)`

**二叉查找树**

- 在二叉查找树中的任意一个结点，其左子树中的每个结点的值，都要小于这个结点的值。
- 在二叉查找树中的任意一个结点，其右子树中每个结点的值，都要大于这个结点的值。
- 在二叉查找树中，会尽可能规避两个结点数值相等的情况。
- 对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。

查找操作

> 时间复杂度 O(logn)

- 首先判断根结点是否等于要查找的数据，如果是就返回。
- 如果根结点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子结点。
- 如果根结点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子结点。

插入操作

> 时间复杂度 O(logn)

- 在二叉查找树执行插入操作也很简单。从根结点开始，如果要插入的数据比根结点的数据大，且根结点的右子结点不为空，则在根结点的右子树中继续尝试执行插入操作。直到找到为空的子结点执行插入动作。

删除操作

二叉查找树的删除操作会比较复杂，这是因为删除完某个结点后的树，仍然要满足二叉查找树的性质。我们分为下面三种情况讨论。

- 情况一，如果要删除的结点是某个叶子结点，则直接删除，将其父结点指针指向 null 即可。
- 情况二，如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可
- 情况三，如果要删除的结点有两个子结点，则有两种可行的操作方式。
  + 第一种，找到这个结点的左子树中最大的结点，替换要删除的结点。
  + 第二种，找到这个结点的右子树中最小的结点，替换要删除的结点。

**案例：**

输入一个字符串，判断它在已有的字符串集合中是否出现过?（假设集合中没有某个字符串与另一个字符串拥有共同前缀且完全包含的特殊情况，例如 deep 和 dee。）如，已有字符串集合包含 6 个字符串分别为，cat, car, city, dog,door, deep。输入 cat，输出 true；输入 home，输出 false

字典树， Trie 树（前缀树）

- 第一，根结点不包含字符；
- 第二，除根结点外每一个结点都只包含一个字符；
- 第三，从根结点到某一叶子结点，路径上经过的字符连接起来，即为集合中的某个字符串。

这个问题的解法可以拆解为以下两个步骤：

- 第一步，根据候选字符串集合，建立字典树。这需要使用数据插入的动作。
- 第二步，对于一个输入字符串，判断它能否在这个树结构中走到叶子结点。如果能，则出现过。

### 哈希表，散列表（Hash）

如果有一种方法，可以实现“地址 = f (关键字)”的映射关系，那么就可以快速完成基于数据的数值的查找了。这就是哈希表的核心思想。

**如何设计哈希函数**

- 第一，直接定制法

  哈希函数为关键字到地址的线性函数。如，H (key) = a*key + b。 这里，a 和 b 是设置好的常数。

- 第二，数字分析法

  假设关键字集合中的每个关键字 key 都是由 s 位数字组成（k1,k2,…,Ks），并从中提取分布均匀的若干位组成哈希地址。

- 第三，平方取中法

  如果关键字的每一位都有某些数字重复出现，并且频率很高，我们就可以先求关键字的平方值，通过平方扩大差异，然后取中间几位作为最终存储地址。

- 第四，折叠法

  如果关键字的位数很多，可以将关键字分割为几个等长的部分，取它们的叠加和的值（舍去进位）作为哈希地址。

- 第五，除留余数法

  预先设置一个数 p，然后对关键字进行取余运算。即地址为 key mod p。

**如何处理哈希冲突**

- 第一，开放定址法

  即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在哈希表中形成一个探测序列，然后沿着这个探测序列依次查找下去。当碰到一个空的单元时，则插入其中

  **常用的探测方法是线性探测法**。 比如有一组关键字 {12，13，25，23}，采用的哈希函数为 key mod 11。当插入 12，13，25 时可以直接插入，地址分别为 1、2、3。而当插入 23 时，哈希地址为 23 mod 11 = 1。然而，地址 1 已经被占用，因此沿着地址 1 依次往下探测，直到探测到地址 4，发现为空，则将 23 插入其中。

- 第二，链地址法

  将哈希地址相同的记录存储在一张线性链表中。

**哈希表不足**

哈希表中的数据是没有顺序概念的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。在数据处理顺序敏感的问题时，选择哈希表并不是个好的处理方法。同时，哈希表中的 key 是不允许重复的，在重复性非常高的数据中，哈希表也不是个好的选择。

**哈希表的基本操作**

哈希表查找的细节过程是：对于给定的 key，通过哈希函数计算哈希地址 H (key)。

- 如果哈希地址对应的值为空，则查找不成功。
- 反之，则查找成功。

### 堆 Heap

大顶堆

小顶堆

### 图 graph

- DFS
- BFC

---

## 算法思维基础

### 递归：利用递归求解汉诺塔问题

**递归的实现包含了两个部分，一个是递归主体，另一个是终止条件。**

在数学与计算机科学中，递归 （Recursion)）是指在函数的定义中使用函数自身的方法，直观上来看，就是某个函数自己调用自己。

递归有两层含义：

- 递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题。并且这些子问题可以用完全相同的解题思路来解决；

- 递归问题的演化过程是一个对原问题从大到小进行拆解的过程，并且会有一个明确的终点（临界点）。一旦原问题到达了这个临界点，就不用再往更小的问题上拆解了。最后，从这个临界点开始，把小问题的答案按照原路返回，原问题便得以解决。

**递归的案例**

汉诺塔问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上，并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

我们可以把这个问题抽象为一个数学问题。如下图所示，从左到右有 x、y、z 三根柱子，其中 x 柱子上面有从小叠到大的 n 个圆盘。现要求将 x 柱子上的圆盘移到 z 柱子上去。要求是，每次只能移动一个盘子，且大盘子不能被放在小盘子上面。求移动的步骤。

```java
public static void main(String[] args) {
    String x = "x";
    String y = "y";
    String z = "z";
    hanio(3, x, y, z);
}
public void hanio(int n, String x, String y, String z) {
    if (n < 1) {
        System.out.println("汉诺塔的层数不能小于1");
    } else if (n == 1) {
        System.out.println("移动: " + x + " -> " + z);
        return;
    } else {
        hanio(n - 1, x, z, y);
        System.out.println("移动: " + x + " -> " + z);
        hanio(n - 1, y, x, z);
    }
}
```

### 分治：如何利用分治法完成数据查找

前面我们讲到分治法的核心思想是“分而治之”，当你需要采用分治法时，**一般原问题都需要具备以下几个特征：**

1. **难度在降低**，即原问题的解决难度，随着数据的规模的缩小而降低。这个特征绝大多数问题都是满足的。
2. **问题可分**，原问题可以分解为若干个规模较小的同类型问题。这是应用分治法的前提。
3. **解可合并**，利用所有子问题的解，可合并出原问题的解。这个特征很关键，能否利用分治法完全取决于这个特征。
4. **相互独立**，各个子问题之间相互独立，某个子问题的求解不会影响到另一个子问题。如果子问题之间不独立，则分治法需要重复地解决公共的子问题，造成效率低下的结果。

**总结**

分治法经常会用在海量数据处理中。这也是它显著区别于遍历查找方法的优势。**在面对陌生问题时，需要注意原问题的数据是否有序，预期的时间复杂度是否带有 logn 项，是否可以通过小问题的答案合并出原问题的答案。如果这些先决条件都满足，你就应该第一时间想到分治法。**

### 排序：经典排序算法原理解析与优劣对比

### 动态规划

### 贪心算法

## 实践

解决代码问题的方法论

1. 复杂度分析 - 估算问题中的上限和下限
2. 定位问题 - 根据问题类型，确定采用何种算法思维
3. 数据操作分析 - 根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间
4. 编码实现

### 案例（一）

**斐波那契数列**

随机一个数字等于前面两个数字之和，开始数字 `0` 和 `1` 如：`[0, 1, 1, 2, 3, 5,  8, 13]` 。

输入 x（索引），输出斐波那契数列中第 x 位的元素：

```javascript
function main() {
  let x = 20
  console.log(query(x))
}

function query(x) {
  if (x === 1) {
     return 0
   }
  if (x === 2) {
     return 1
  }
  return query(x - 1) + query(x - 2)
}

main()
```

